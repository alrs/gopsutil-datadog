// +build linux

package process

import (
	"os"
	"testing"

	log "github.com/cihub/seelog"
	"github.com/stretchr/testify/assert"
)

var sink map[int32]*FilledProcess

func BenchmarkLinuxAllProcessesOnPostgresProcFS(b *testing.B) {
	var err error
	errCount := 0

	// Set procfs to testdata location, does not include:
	//  /fd  - fd count
	//  /exe - symlink
	//  /cwd - symlink
	os.Setenv("HOST_PROC", "resources/linux_postgres/proc")
	defer os.Unsetenv("HOST_PROC")

	// Disable logging (as it'll be noisy)
	log.ReplaceLogger(log.Disabled)

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		if sink, err = AllProcesses(); err != nil {
			errCount++
		}
	}

	if errCount > 0 {
		b.Fatal("non-zero errors for AllProcesses", errCount)
	}
}

func BenchmarkLinuxAllProcessesOnLocalProcFS(b *testing.B) {
	var err error
	errCount := 0

	// Disable logging (as it'll be noisy)
	log.ReplaceLogger(log.Disabled)

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		if sink, err = AllProcesses(); err != nil {
			errCount++
		}
	}

	if errCount > 0 {
		b.Fatal("non-zero errors for AllProcesses", errCount)
	}
}

func TestFillNsPidFromStatus(t *testing.T) {
	err := os.Setenv("HOST_PROC", "./resources/linux_inner_ns/proc")
	defer os.Unsetenv("HOST_PROC")
	assert.Nil(t, err)

	t.Run("Linux versions 4.1+", func(t *testing.T) {
		// Process started on the host namespace
		// NSpid:	6320
		pid := int32(6320)
		p1, err := NewProcess(pid)
		assert.Nil(t, err)
		p1.fillFromStatus()
		assert.Equal(t, int32(pid), p1.Pid)
		assert.Equal(t, int32(pid), p1.NsPid)

		// Process spawned from P1 with its own namespace
		// NSpid:	6321	1
		pid = int32(6321)
		p2, err := NewProcess(pid)
		assert.Nil(t, err)
		p2.fillFromStatus()
		assert.Equal(t, int32(pid), p2.Pid)
		assert.Equal(t, int32(1), p2.NsPid)

		// Process spawned from P2 with its own namespace
		// NSpid:	6322	2	1
		pid = int32(6322)
		p3, err := NewProcess(pid)
		assert.Nil(t, err)
		p3.fillFromStatus()
		assert.Equal(t, int32(pid), p3.Pid)
		assert.Equal(t, int32(1), p3.NsPid)
	})

	t.Run("Older Linux versions", func(t *testing.T) {
		// The following processes have been generated by the same testing program but
		// older versions of Linux don't provide the NSpid on the status file.
		// We expect the library not to populate the NsPid field
		// True NSpid:	8225
		pid := int32(8225)
		p1, err := NewProcess(pid)
		assert.Nil(t, err)
		p1.fillFromStatus()
		assert.Equal(t, int32(pid), p1.Pid)
		assert.Equal(t, int32(0), p1.NsPid)

		// Process spawned from P1 with its own namespace
		// True NSpid:	8226	1
		pid = int32(8226)
		p2, err := NewProcess(pid)
		assert.Nil(t, err)
		p2.fillFromStatus()
		assert.Equal(t, int32(pid), p2.Pid)
		assert.Equal(t, int32(0), p2.NsPid)

		// Process spawned from P2 with its own namespace
		// True NSpid:	8227	2	1
		pid = int32(8227)
		p3, err := NewProcess(pid)
		assert.Nil(t, err)
		p3.fillFromStatus()
		assert.Equal(t, int32(pid), p3.Pid)
		assert.Equal(t, int32(0), p3.NsPid)
	})
}

func TestProcCatSmaps(t *testing.T) {
	err := os.Setenv("HOST_PROC", "./resources/linux_cat_smaps/proc")
	defer os.Unsetenv("HOST_PROC")
	assert.Nil(t, err)

	pid := int32(12345)
	p, err := NewProcess(pid)
	assert.Nil(t, err)

	mms, err := p.MemoryMaps(true)
	assert.Nil(t, err)

	pathFoundMap := make(map[string]bool)
	pathFound := []string{}
	for _, m := range *mms {
		if _, found := pathFoundMap[m.Path]; !found {
			pathFoundMap[m.Path] = true
			pathFound = append(pathFound, m.Path)
		}

		if m.Size == 0 {
			t.Errorf("section %+v have zero Size", m)
		}

		if m.IsAnonymous() && (m.Device != "00:00" || m.Inode != 0) {
			t.Errorf("anonymous section %+v don't have correct device/inode", m)
		}
	}

	expected := []string{
		"", // anonymous map
		"/usr/bin/cat",
		"[heap]",
		"/usr/lib/locale/locale-archive",
		"/usr/lib/libc-2.33.so",
		"/usr/lib/ld-2.33.so",
		"/usr/lib/fake lib with space-2.33.so",
		"[stack]",
		"[vvar]",
		"[vdso]",
		"[vsyscall]",
	}
	assert.ElementsMatch(t, expected, pathFound)
}
